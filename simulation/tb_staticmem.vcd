$date
  Wed May  9 17:26:06 2018
$end
$version
  GHDL v0
$end
$timescale
  1 fs
$end
$var reg 8 ! charinput[7:0] $end
$var reg 1 " iscorrect $end
$scope module u1 $end
$var reg 8 # charinput[7:0] $end
$var reg 1 $ iscorrect $end
$var reg 26 % auxvector[25:0] $end
$var reg 8 & auxdata[7:0] $end
$var reg 8 ' auxdatab[7:0] $end
$scope module ur1 $end
$var integer 32 ( address $end
$var reg 8 ) data[7:0] $end
$upscope $end
$scope module uc1 $end
$var reg 8 * charinputa[7:0] $end
$var reg 8 + charinputb[7:0] $end
$var reg 1 , bitoutput $end
$var reg 1 - a1 $end
$var reg 1 . a2 $end
$var reg 1 / a3 $end
$var reg 1 0 a4 $end
$var reg 1 1 a5 $end
$var reg 1 2 a6 $end
$var reg 1 3 a7 $end
$var reg 1 4 a8 $end
$upscope $end
$scope module ur2 $end
$var integer 32 5 address $end
$var reg 8 6 data[7:0] $end
$upscope $end
$scope module uc2 $end
$var reg 8 7 charinputa[7:0] $end
$var reg 8 8 charinputb[7:0] $end
$var reg 1 9 bitoutput $end
$var reg 1 : a1 $end
$var reg 1 ; a2 $end
$var reg 1 < a3 $end
$var reg 1 = a4 $end
$var reg 1 > a5 $end
$var reg 1 ? a6 $end
$var reg 1 @ a7 $end
$var reg 1 A a8 $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
b00000000 !
0"
b00000000 #
0$
bUUUUUUUUUUUUUUUUUUUUUUUU00 %
b01100001 &
b01100010 '
b0 (
b01100001 )
b00000000 *
b01100001 +
0,
0-
1.
1/
10
11
02
03
14
b1 5
b01100010 6
b00000000 7
b01100010 8
09
1:
0;
1<
1=
1>
0?
0@
1A
#1000000
b00001000 !
b00001000 #
b00001000 *
00
b00001000 7
0=
#2000000
b00000000 !
b00000000 #
b00000000 *
10
b00000000 7
1=
#3000000
b01100001 !
1"
b01100001 #
1$
bUUUUUUUUUUUUUUUUUUUUUUUU01 %
b01100001 *
1,
1-
12
13
b01100001 7
0:
1?
1@
#6000000
b01100010 !
b01100010 #
bUUUUUUUUUUUUUUUUUUUUUUUU10 %
b01100010 *
0,
0-
0.
b01100010 7
19
1:
1;
